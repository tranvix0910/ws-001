[
{
	"uri": "//localhost:1313/",
	"title": "DevSecOps Pipeline",
	"tags": [],
	"description": "",
	"content": "Triển khai quy trình pipeline DevSecOps Tổng quan Trong bài Workshop này, bạn sẽ tìm hiểu cơ bản về quy trình DevSecOps — sự kết hợp giữa phát triển (Dev), vận hành (Ops), và bảo mật (Sec) để xây dựng một quy trình CI/CD toàn diện và bảo mật. Workshop sẽ hướng dẫn bạn sử dụng các công cụ như GitLab CI/CD, Docker, Portus và k6 để triển khai các giải pháp DevSecOps hiệu quả trên cơ sở hạ tầng on-premise.\nNội dung Giới thiệu Thiết lập dự án Thiết lập CI/CD Pipeline "
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Giới thiệu DevSecOps DevSecOps là phương pháp tích hợp kiểm thử bảo mật ở mọi giai đoạn của quy trình phát triển phần mềm. Phương pháp này bao gồm các công cụ và quy trình khuyến khích cộng tác giữa các nhà phát triển, chuyên gia bảo mật và đội ngũ vận hành nhằm xây dựng phần mềm vừa hiệu quả vừa an toàn. DevSecOps mang đến sự chuyển đổi văn hóa, biến việc bảo mật trở thành trách nhiệm chung đối với tất cả các cá nhân xây dựng phần mềm.\nDevSecOps là viết tắt của development (phát triển), security (bảo mật) và operations (vận hành). Đây là một phần mở rộng của phương pháp DevOps. Mỗi thuật ngữ đều xác định vai trò và trách nhiệm khác nhau của các đội ngũ phần mềm khi xây dựng ứng dụng phần mềm.\nDevelopment (phát triển)\nPhát triển là quá trình lập kế hoạch, mã hóa, xây dựng và thử nghiệm ứng dụng.\nSecurity (bảo mật)\nBảo mật có nghĩa là giới thiệu bảo mật sớm hơn trong chu trình phát triển phần mềm. Ví dụ, các lập trình viên đảm bảo rằng mã không có lỗ hổng bảo mật, và các học viên bảo mật kiểm tra phần mềm thêm trước khi công ty phát hành nó.\nOperations (vận hành)\nNhóm hoạt động phát hành, giám sát và sửa chữa bất kỳ vấn đề phát sinh từ phần mềm.\nNội dung Quy trình DevSecOps Gitlab CI/CD DevSecOps Tools "
},
{
	"uri": "//localhost:1313/1-introduce/1.1-implementationprocess/",
	"title": "Quy trình DevSecOps",
	"tags": [],
	"description": "",
	"content": "Cấu trúc quy trình DevSecOps Quy trình DevSecOps là một chuỗi các quy trình và công cụ tự động giúp xây dựng, thử nghiệm và phân phối ứng dụng trong môi trường sản xuất cũng như bảo mật chúng ở mọi giai đoạn. Thông thường các công ty sẽ có 3 môi trường để triển khai dự án chính là Dev, Stagging, Production, một số các công ty lớn hơn thì có nhiều môi trường hơn như UAT, Sandbox.\nDev (Development Phase) SAST (Static Application Security Testing): Đây là bước đầu tiên trong giai đoạn phát triển. SAST phân tích mã nguồn của ứng dụng để phát hiện các lỗ hổng bảo mật tiềm ẩn. Việc kiểm tra này diễn ra mà không cần chạy chương trình, giúp phát hiện sớm các vấn đề bảo mật ngay trong quá trình phát triển. SCA (Software Composition Analysis): Sau SAST, SCA được thực hiện để kiểm tra các thành phần phần mềm bên thứ ba (như thư viện và gói mã nguồn mở) được sử dụng trong dự án. SCA giúp phát hiện các lỗ hổng bảo mật đã biết trong các thành phần này. Build: Sau khi kiểm tra bảo mật, mã nguồn sẽ được xây dựng thành một ứng dụng có thể thực thi. Quá trình này có thể bao gồm việc biên dịch mã, tạo ra các gói ứng dụng, và các bước cần thiết khác để chuẩn bị ứng dụng sẵn sàng để triển khai. Deploy: Ứng dụng sau khi xây dựng được triển khai lên môi trường kiểm thử hoặc staging để tiếp tục kiểm tra. Unit Test: Ở giai đoạn này, các bài kiểm tra đơn vị (Unit Test) được thực hiện để đảm bảo từng thành phần của mã nguồn hoạt động đúng theo yêu cầu. Repository (Artifact Management Phase) Artifact Registry: Sau khi ứng dụng đã được kiểm thử và triển khai, nó sẽ được lưu trữ trong một kho lưu trữ (artifact registry). Kho lưu trữ này sẽ lưu giữ các phiên bản khác nhau của ứng dụng để dễ dàng quản lý và triển khai sau này. Image Scan: Ảnh Docker hoặc các hình ảnh triển khai khác sẽ được quét để phát hiện các lỗ hổng bảo mật. Đây là bước kiểm tra bảo mật cho các thành phần triển khai (deployment artifacts) trước khi chúng được chuyển sang các giai đoạn tiếp theo. Pre-Prod (Pre-Production Phase) Container: Ứng dụng sẽ được triển khai dưới dạng container để chuẩn bị cho việc kiểm thử trước khi triển khai lên môi trường sản xuất. DAST (Dynamic Application Security Testing): Kiểm thử bảo mật động (DAST) được thực hiện trên ứng dụng đang chạy để phát hiện các lỗ hổng bảo mật có thể chỉ xuất hiện khi ứng dụng hoạt động. Performance Test: Kiểm thử hiệu suất được thực hiện để đánh giá khả năng chịu tải và hiệu suất của ứng dụng dưới các điều kiện khác nhau. Điều này giúp đảm bảo rằng ứng dụng có thể hoạt động tốt khi triển khai lên môi trường sản xuất. Prod (Production Phase) K8s (Kubernetes): Ứng dụng được triển khai lên môi trường sản xuất, thường là trên nền tảng Kubernetes (K8s) để quản lý và vận hành. Pen Test (Penetration Testing): Kiểm thử xâm nhập (Pen Test) được thực hiện trên môi trường sản xuất để phát hiện các lỗ hổng bảo mật mà có thể đã bị bỏ sót trong các giai đoạn trước đó. Report: Cuối cùng, các báo cáo về bảo mật, hiệu suất và kết quả kiểm thử sẽ được tổng hợp lại để đánh giá toàn diện về tình trạng của ứng dụng trước và sau khi triển khai lên sản xuất. "
},
{
	"uri": "//localhost:1313/2-preparation/2.1-setupservers/",
	"title": "Thiết lập các Server cho dự án",
	"tags": [],
	"description": "",
	"content": "Gitlab Server Chúng ta sẽ tiến hành thiết lập GitLab EE (Enterprise Edition) trên máy chủ nhằm lưu trữ mã nguồn và cấu hình quá trình CI/CD.\nĐể thực hiện, chúng ta sẽ sử dụng hệ điều hành Ubuntu phiên bản 24.04 để cài đặt trên máy ảo.\nLink file ISO Ubuntu Server 24.04 Tiến hành tạo máy ảo theo các bước sau:\nChú ý chọn file ISO vừa tải về.\nĐặt tên và chọn thư mục lưu trữ Server nhầm mục đích dễ quản lý.\nTùy theo cấu hình của máy bạn mà có thể chọn Processors và Cores phù hợp, tuy nhiên Gitlab cần tối thiểu 2 CPU (Processor Cores).\nTiếp theo chọn theo các cấu hình mặc định.\nTiếp theo thiết lập Ubuntu Server\nTiếp tục chọn theo cấu hình mặc định. Ở mục Storage Configuration thiết lập phân vùng Root ( / ) bằng toàn bộ dung lượng còn lại.\nCài đặt OpenSSH.\nĐợi Ubuntu thiết lập thành công và tiến hành Reboot.\nSau khi Reboot, đăng nhập vào Server vào username và pass vừa tạo. Chú ý IPv4 khi vừa đăng nhập, dùng để SSH vào Server. Có thể sử dụng lệnh ip a để xem IPv4 và các thông tin khác của Server.\nMở CMD trên Windows để SSH vào Server thông qua IPv4 và Username.\nTuy nhiên khi tắt Server và bật lại IPv4 có thể thay đổi, chúng ta tiến hành thiết lập IP tĩnh cho Server.\nChuyển sang quyền Root bằng lệnh sudo -i cho quá trình thiết lập dễ thao tác.\nChỉnh sửa cấu hình trong file 50-cloud-init.yaml bằng lệnh vi /etc/netplan/50-cloud-init.yaml và viết theo cấu hình sau:\n# This is the network config written by \u0026#39;subiquity\u0026#39; network: ethernets: ens33: dhcp4: no addresses: [192.168.181.100/24] gateway4: 192.168.181.2 nameservers: addresses: [8.8.8.8, 8.8.4.4] version: 2 Tiến hành lưu file bằng tổ hợp phím sau: ESC + :wq và tiến hành chạy lệnh:\n$ netplan apply $ reboot Ở dòng gateway4 là IP Gateway của NAT có thể lấy ở VMware bằng cách truy cập vào Edit -\u0026gt; Virtual Network Editor -\u0026gt; NAT Setting\nSau khi chỉnh sửa IP tĩnh thành công tiến hành tạo Snapshot và Clone ra các Server khác.\nClick phải vào Gitlab Server -\u0026gt; Snapshot -\u0026gt; Take Snapshot và điền các thông tin.\nSau đó chọn theo ảnh và Clone ra các Server khác.\nClone Server và thay đổi IP tĩnh, Hostname của các Server theo bảng sau:\nServer Hostname IP Gitlab Server gitlab-server 192.168.181.100 Development Server development-server 192.168.181.101 Build Server build-server 192.168.181.102 Database Server database-server 192.168.181.103 "
},
{
	"uri": "//localhost:1313/3-pipeline/3.1-gitlab-runner/",
	"title": "Thiết lập Gitlab Runner",
	"tags": [],
	"description": "",
	"content": "Cài đặt Gitlab Runner Để đảm bảo mỗi server có thể thực hiện nhiệm vụ build và triển khai một cách hiệu quả, chúng ta sẽ tiến hành cài đặt GitLab Runner trên cả Server Development và Server Build.\nCài đặt Gitlab Runner theo các lệnh sau:\napt update -y\rcurl -L \u0026#34;https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh\u0026#34; | sudo bash\rapt install gitlab-runner Trước đây, chúng ta đã thảo luận về các loại GitLab Runner khác nhau và cách chúng phù hợp với các nhu cầu dự án ( mục 1.3 ). Khi triển khai, bạn có thể chọn chiến lược phù hợp nhất với đặc thù dự án của bạn.\nTrong buổi Workshop này, chúng ta sẽ tập trung vào việc triển khai Group Runner, một lựa chọn linh hoạt và mạnh mẽ cho phép tất cả các dự án trong nhóm được xử lý bởi cùng một Runner. Điều này giúp tối ưu hóa tài nguyên và đảm bảo tính nhất quán trong quá trình CI/CD.\nGitlab Runner đã cài đặt thành công ở 2 Server.\nCấu hình Gitlab Runner Truy cập Groups -\u0026gt; Build -\u0026gt; Runners.\nChọn New group runner.\nĐặt Tags và Tạo Runner, chú ý tick chọn Run untagged jobs.\nSau đó, Gitlab sẽ hướng dấn chúng ta cách để đăng ký Gitlab-Runner với máy ảo:\nThực hiện Step 1:\ngitlab-runner register --url http://gitlab.tranvix.vn --token glrt-DneB3yejRa5zd3F5xLKs Sau khi thực hiện thành công ở cả 2 Server tiến hành kiểm tra tại Gitlab.\nNhư vậy đã thiết lập Gitlab thành công.\n"
},
{
	"uri": "//localhost:1313/3-pipeline/3.2-build-and-push-image/",
	"title": "Build và Push Docker Image",
	"tags": [],
	"description": "",
	"content": "Thiết lập các cấu hình cần thiết. Trước khi tạo Dockerfile, bạn cần cập nhật giá trị BASE_URL trong frontend để trỏ đến địa chỉ server backend mà bạn sẽ deploy. Cụ thể, bạn cần thay đổi thông số này trong file cấu hình của frontend.\nĐể thực hiện điều này trên GitLab, hãy làm theo các bước sau:\nTruy cập file cấu hình:\nTrong dự án frontend của bạn trên GitLab, điều hướng đến file cấu hình src/config/utils.js.\nThay đổi giá trị BASE_URL để trỏ tới server deploy backend hiện tại.\nTiếp theo chúng ta sẽ thực hiện tạo một nhánh ( branch ) mới.\nĐể đảm bảo tính ổn định của nhánh chính (Main), hãy tạo một nhánh mới để thực hiện các thay đổi. Điều này giúp giữ cho nhánh Main không bị ảnh hưởng trong quá trình phát triển.\nTruy cập vào dấu + và chọn New Branch. Chúng ta sẽ đặt tên và tạo Branch.\nChúng ta sẽ thực hiện thêm một số cấu hình sau để đảm bảo tính bảo mật.\nTruy cập vào Settings -\u0026gt; Repository\nThay đổi nhánh mặc định thành nhánh vừa tạo, việc này nhầm mục địch khi chúng ta truy cập vào Project, Source code của nhánh Develop sẽ xuất hiện đầu tiên.\nTiếp theo chúng ta sẽ thực hiện Protect Branch, khi bảo vệ nhánh có thể giữ an toàn cho nhánh tránh các tình huống Push và Merge.\nThêm User Gitlab-Runner vào Group Docker Trong quá trình chạy Pipeline, User gitlab-runner sẽ được dùng để chạy dự án.\nViệc thêm gitlab-runner vào Group Docker giúp cho User có thể thực hiện các câu lệnh Docker như : Login, Logout Build và Push Image.\nsudo usermod -aG docker gitlab-runner sudo: Chạy lệnh với quyền quản trị.\nusermod: Công cụ để sửa đổi tài khoản người dùng.\n-aG docker: Tùy chọn -aG thêm người dùng vào nhóm chỉ định mà không loại họ khỏi các nhóm khác.\ngitlab-runner: Tên của người dùng cần thêm vào nhóm docker.\nTạo Dockerfile Truy cập vào Web IDE để tiện cho việc thao tác.\nTạo Dockerfile cho Frontend:\n##### Dockerfile ##### ## build stage ## FROM node:22-alpine AS build WORKDIR /app COPY . . RUN npm install RUN npm run build ## run stage ## FROM nginx:alpine COPY --from=build /app/build /usr/share/nginx/html EXPOSE 80 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon off;\u0026#34;] Tạo Gitlab CI/CD Tiến hành tạo file .gitlab-ci.yml.\nTệp .gitlab-ci.yml là một tệp cấu hình được sử dụng trong GitLab CI/CD. Nó định nghĩa các pipeline, các job, và các stage để tự động hóa các tác vụ như xây dựng, kiểm thử và triển khai mã nguồn khi có sự thay đổi trong kho lưu trữ (repository).\nvariables: PROJECT_USER: \u0026#34;wineapp\u0026#34; IMAGE_VERSION: \u0026#34;${PORTUS_URL}/${PROJECT_USER}/${CI_PROJECT_NAME}:${CI_COMMIT_TAG}_${CI_COMMIT_SHORT_SHA}\u0026#34; stages: - build - push build: stage: build variables: GIT_STRATEGY: clone before_script: - docker login -u ${PORTUS_USER} -p ${PORTUS_PASSWORD} ${PORTUS_URL} script: - docker build -t ${IMAGE_VERSION} . after_script: - docker logout ${PORTUS_URL} tags: - wineapp-build-shell only: - tags push: stage: push variables: GIT_STRATEGY: none before_script: - docker login -u ${PORTUS_USER} -p ${PORTUS_PASSWORD} ${PORTUS_URL} script: - docker push ${IMAGE_VERSION} after_script: - docker logout ${PORTUS_URL} tags: - wineapp-build-shell only: - tags Tệp cấu hình GitLab CI/CD được viết bằng YAML.\nTrước khi giải thích chi tiết về file cấu hình trên, chúng ta sẽ tìm hiểu về Biến (Variables) trong Gitlab CI/CD.\nVariables có 2 loại chính:\nBiến mặc định (Predefined Variables):\nĐược GitLab cung cấp tự động trong mỗi pipeline. Ví dụ: CI_COMMIT_SHA: SHA của commit hiện tại. CI_JOB_ID: ID của công việc (job) hiện tại. CI_PROJECT_NAME: Tên của dự án. CI_COMMIT_REF_NAME: Tên nhánh (branch) hoặc tag của commit hiện tại. CI_PIPELINE_ID: ID của pipeline. Biến do người dùng định nghĩa (User-defined Variables):\nĐược người dùng tự định nghĩa trong tệp .gitlab-ci.yml hoặc trong phần cài đặt của dự án trên GitLab. Định nghĩa trong .gitlab-ci.yml: variables: PROJECT_USER: \u0026#34;wineapp\u0026#34; PORTUS_URL: \u0026#34;https://registry.example.com\u0026#34; Định nghĩa trong cài đặt dự án Project Settings \u0026gt; CI/CD \u0026gt; Variables:\nCó thể được thiết lập ở mức dự án, nhóm, hoặc pipeline cụ thể.\nHỗ trợ tính năng protected, masked, và scoped (cho phép giới hạn biến chỉ trong một số môi trường hoặc nhánh cụ thể).\nTrong dự án, Đầu tiên sẽ khai báo các biến (Variables):\nPROJECT_USER: Được dùng để định nghĩa User để triển khai dự án.\nIMAGE_VERSION: Tạo tag cho Docker image sử dụng một số biến:\n${PORTUS_URL}: URL của Docker registry (có thể là Portus).\n${PROJECT_USER}: Người dùng dưới đó image sẽ được lưu trữ.\n${CI_PROJECT_NAME}: Tên dự án.\n${CI_COMMIT_TAG}: Tag gắn với commit (có thể là số phiên bản).\n${CI_COMMIT_SHORT_SHA}: Phiên bản rút gọn của SHA commit.\nChúng ta có thể lấy giá trị của biến bằng cách ${\u0026lt;Variable\u0026gt;}\nTiếp theo chúng ta sẽ tạo các Stage cho Pipeline:\nChúng ta sẽ định nghĩa pipeline chúng ta có 2 giai đoạn chính là build và push.\nbuild: Giai đoạn mà Docker image được xây dựng.\npush: Giai đoạn mà Docker image đã xây dựng được đẩy lên Docker registry.\nStage Build chúng ta sẽ thực hiện những bước sau:\nGIT_STRATEGY: clone : Chỉ định rằng kho mã nguồn sẽ được clone (hành vi mặc định).\nbefore_script : Các lệnh được thực hiện trước khi chạy script chính. Đăng nhập vào Docker registry sử dụng thông tin đăng nhập được lưu trong các biến môi trường ${PORTUS_USER} và ${PORTUS_PASSWORD}.\nscript : Phần chính của giai đoạn này, xây dựng Docker image với tag IMAGE_VERSION đã được chỉ định.\nafter_script : Đăng xuất khỏi Docker registry sau khi quá trình build hoàn thành.\ntags : Chỉ định runner (wineapp-build-shell) sẽ được sử dụng cho công việc này.\nonly : Đảm bảo công việc này chỉ chạy khi một Git Tag được đẩy lên.\nThông thường khi code chúng ta có thay đổi Gitlab CI/CD sẽ tiến hành khởi động Pipeline, Tuy nhiên khi chúng ta khai báo only: -tags, việc chạy Pipeline sẽ được tiến hành khi chúng ta tạo Tag.\nStage Push tương tự như Stage Build tuy nhiên chúng ta sẽ khai báo khác một tí:\nGIT_STRATEGY : none : chúng ta sẽ không cần clone mã nguồn về ở giai đoạn này, vì mã nguồn đã được clone ở Stage trước.\nscript: Đẩy Docker image đã được xây dựng lên Docker registry.\nTạo Variables Sau khi tạo file thành công chúng ta sẽ Commit và tạo các Variables.\nTruy cập Project Settings \u0026gt; CI/CD \u0026gt; Variables:\nTiến hành tạo một số biến chúng ta đã định nghĩa tại Pipeline ( trừ một số biến mặc định của Gitlab CI/CD ).\nProtect variable : Các biến chỉ chạy trên các Branch và Tag được Protect.\nExpand variable reference: Bất kỳ ký tự $ nào trong giá trị của biến sẽ được xử lý như một tham chiếu đến một biến khác.\nVí dụ : PROJECT_NAME có giá trị là myapp.\nPORTUS_URL có giá trị là https://registry.example.com/$PROJECT_NAME.\nNhư vậy đã thêm các biến thành công.\nKhởi tạo Pipeline Chúng ta sẽ tiến hành tạo Tag:\nĐặt tên Tag và chú ý chọn đúng Branch.\nSau khi tạo Tag, Pipeline sẽ được khởi động.\nJob Build Thành công.\nJob Push Thành công.\nKhi truy cập vào Portus, Repository đã được Push thành công.\n"
},
{
	"uri": "//localhost:1313/1-introduce/1.2-gitlabcicd/",
	"title": "Gitlab CI/CD",
	"tags": [],
	"description": "",
	"content": "Gitlab GitLab là một nền tảng DevOps toàn diện, tích hợp nhiều công cụ để quản lý toàn bộ vòng đời phát triển phần mềm. Với GitLab, các nhóm phát triển có thể dễ dàng quản lý mã nguồn, tự động hóa quy trình kiểm thử và triển khai thông qua các tính năng tích hợp liên tục (CI) và triển khai liên tục (CD). Ngoài ra, GitLab còn cung cấp các công cụ quản lý dự án, theo dõi tiến độ và cộng tác hiệu quả, giúp cải thiện chất lượng và tốc độ phát triển phần mềm.\nGitLab có hai phiên bản chính: GitLab CE (Community Edition), một phiên bản mã nguồn mở miễn phí với các tính năng cơ bản, và GitLab EE (Enterprise Edition), phiên bản thương mại cung cấp nhiều tính năng nâng cao và hỗ trợ kỹ thuật chuyên nghiệp.\nCI/CD CI/CD là một phương pháp thường xuyên cung cấp ứng dụng cho khách hàng bằng cách đưa tự động hóa vào các giai đoạn phát triển ứng dụng. Khái niệm chính CI/CD là Continuous Integration, Continuous deployment, phân phối liên tục và triển khai liên tục. CI/CD là một giải pháp khăc phục các vấn đề khi tích hợp, deploy code mới trong quá trình dự án vận hành và phát triển\nCI/CD giúp tự động hóa, giám sát liên tục trong suốt vòng đời phát triển phần mềm, từ giai đoạn tích hợp và thử nghiệm đến phân phối và triển khai.\nQuá trình này là một phần của quy trình DevOps và DevSecOps:\nGitlab CI/CD GitLab CI/CD (Continuous Integration and Continuous Deployment/Delivery) là một phần của GitLab, một nền tảng DevOps mã nguồn mở tích hợp cung cấp các công cụ để quản lý toàn bộ vòng đời của một dự án phần mềm (software development life cycle). GitLab CI/CD giúp tự động hóa quy trình xây dựng (Build), kiểm thử (Test) và triển khai mã nguồn (Deploy), giúp cải thiện chất lượng phần mềm và tăng cường hiệu quả làm việc.\nCác thành phần chính của GitLab CICD:\nPipeline: Là một tập hợp các Jobs (công việc) được thực thi theo một thứ tự xác định. Mỗi pipeline có thể có nhiều stages (giai đoạn), và mỗi stage có thể có nhiều jobs.\nJob: Là một đơn vị công việc cụ thể, ví dụ như biên dịch mã nguồn, chạy kiểm thử, hoặc triển khai ứng dụng. Các jobs trong cùng một stage được thực thi song song, còn các stages được thực thi tuần tự.\nRunner: Là các agent chịu trách nhiệm thực thi các jobs. GitLab Runner có thể được cài đặt trên máy chủ riêng hoặc sử dụng các runners được cung cấp bởi GitLab.\n.gitlab-ci.yml: Là tệp cấu hình được lưu trữ trong kho mã nguồn (repository) của bạn. Tệp này xác định các pipelines, stages và jobs cần thực thi. Đây là nơi bạn định nghĩa logic CI/CD cho dự án của mình.\nTrong bài workshop này chúng ta sẽ tiến hành self-host Gitlab để triển khai dự án đảm bảo tính bảo mật, có thể toàn quyền kiểm soát Gitlab trong môi trường doanh nghiệp phù hợp với thực tế.\n"
},
{
	"uri": "//localhost:1313/2-preparation/2.2-containerregistry/",
	"title": "Private Container Registry - Portus",
	"tags": [],
	"description": "",
	"content": "Cài Đặt Portus Trước khi tạo Server Portus bạn cần thuê một Domain để có thể truy cập Portus thông qua Domain.\nportus.tranvix.online Tạo Server EC2 để tiến hành cài đặt Portus.\nChọn Launch Instance để tạo Instance. Thiết lập tên của Server. Chọn hệ điều hành, ở đây mình chọn Ubuntu 24.04. Chọn cấu hình Instance phù hợp và thiết lập Key Pair.\nChú ý khi tạo Key Pair, Private Key sẽ được tải về máy, chú ý không để mất và không được chia sẽ cho ai!\nChú ý tick chọn Allow HTTPS traffic from the internet.\nThiết lập này cho phép mọi người truy cập máy chủ web của bạn một cách an toàn từ bất cứ đâu trên thế giới thông qua HTTPS. Chọn dung lượng cho Instance. Sau khi tạo Instance thành công, Tiến hành truy cập vào Instance. Như vậy là đã truy cập thành công vào Instance. Cài đặt các công cụ cần thiết.\napt install -y docker.io docker-compose certbot net-tools Lấy chứng chỉ SSL/TLS: Certbot tự động hóa quy trình đăng ký chứng chỉ từ Let\u0026rsquo;s Encrypt. Chỉ cần cung cấp thông tin cần thiết và Certbot như domain và email.\nChạy một lệnh Certbot để lấy chứng chỉ SSL cho một domain cụ thể.\ncertbot certonly --standalone -d portus.tranvix.online --preferred-challenges http --agree-tos -m your-email@gmail.com --keep-until-expiring Saving debug log to /var/log/letsencrypt/letsencrypt.log\r- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\rWould you be willing, once your first certificate is successfully issued, to\rshellare your email address with the Electronic Frontier Foundation, a founding\rpartner of the Let\u0026#39;s Encrypt project and the non-profit organization that\rdevelops Certbot? We\u0026#39;d like to send you email about our work encrypting the web,\rEFF news, campaigns, and ways to support digital freedom.\r- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r(Y)es/(N)o: Y\rAccount registered.\rRequesting a certificate for portus.tranvix.online\rSuccessfully received certificate.\rCertifiate is saved at: /etc/letsencrypt/live/portus.tranvix.online/fullchain.pem \u0026lt;----------------\rKey is saved at: /etc/letsencrypt/live/portus.tranvix.online/privkey.pem \u0026lt;----------------\rThis certificate expires on 2024-10-16.\rThese files will be updated when the certificate renews.\rCertbot has set up a scheduled task to automatically renew this certificate in the background.\r- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\rIf you like Certbot, please consider supporting our work by:\r* Donating to ISRG / Let\u0026#39;s Encrypt: https://letsencrypt.org/donate\r* Donating to EFF: https://eff.org/donate-le\r- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Chú ý path tới Certifiate và Key vừa tạo.\nClone Portus.\ngit clone https://github.com/SUSE/Portus.git Di chuyển đến thư mục cài đặt Portus.\ncd Portus/examples/compose root@ip-172-31-44-184:/tools/portus/Portus/examples/compose# ls -l total 48 -rw-r--r-- 1 root root 3715 Jul 18 10:31 README.md drwxr-xr-x 2 root root 4096 Jul 18 10:31 clair -rw-r--r-- 1 root root 4345 Jul 18 10:31 docker-compose.clair-ssl.yml -rw-r--r-- 1 root root 3540 Jul 18 10:31 docker-compose.clair.yml -rw-r--r-- 1 root root 3048 Jul 18 10:31 docker-compose.insecure.yml -rw-r--r-- 1 root root 4640 Jul 18 10:31 docker-compose.ldap.yml -rw-r--r-- 1 root root 3656 Jul 18 10:31 docker-compose.yml drwxr-xr-x 2 root root 4096 Jul 18 10:31 nginx drwxr-xr-x 2 root root 4096 Jul 18 10:31 registry drwxr-xr-x 2 root root 4096 Jul 18 10:31 secrets Tiến hành cấu hình Nginx:\nvi nginx/nginx.conf ssl on; ------\u0026gt; Comment dòng này # Certificates ssl_certificate /secrets/portus.crt; \u0026lt;------- ssl_certificate_key /secrets/portus.key; \u0026lt;------- Chú ý đường dẫn tới 2 Key: /secrets/portus.crt, /secrets/portus.key.\nTiến hành copy và đổi tên cặp key SSL mà chúng ta đã tạo ở trên vào 2 thư mục này.\nroot@ip-172-31-44-184:/tools/portus/compose# cp /etc/letsencrypt/live/portus.tranvix.online/fullchain.pem secrets/portus.crt\rroot@ip-172-31-44-184:/tools/portus/compose# cp /etc/letsencrypt/live/portus.tranvix.online/privkey.pem secrets/portus.key Cấu hình file .env\nroot@ip-172-31-44-184:/tools/portus/compose# cat .env MACHINE_FQDN=172.17.0.1 \u0026lt;-------- SECRET_KEY_BASE=b494a25faa8d22e430e843e220e424e10ac84d2ce0e64231f5b636d21251eb6d267adb042ad5884cbff0f3891bcf911bdf8abb3ce719849ccda9a4889249e5c2 PORTUS_PASSWORD=12341234 DATABASE_PASSWORD=portus Thay đổi Port localhost thành Domain của chúng ta.\nMACHINE_FQDN=portus.tranvix.online SECRET_KEY_BASE=b494a25faa8d22e430e843e220e424e10ac84d2ce0e64231f5b636d21251eb6d267adb042ad5884cbff0f3891bcf911bdf8abb3ce719849ccda9a4889249e5c2 PORTUS_PASSWORD=12341234 DATABASE_PASSWORD=portus Tiến hành chạy file docker-compose.clair-ssl.yml.\ndocker-compose -f docker-compose.clair-ssl.yml up -d Như vậy Portus đã cài đặt thành công.\nCấu Hình Portus Thông qua IP Public từ Instance vừa tạo chúng ta có thể tạo Record từ Domain để trỏ tới Server Portus để truy cập Instance thông qua Domain. Tiến hành truy cập vào Domain. Tạp User Admin và đăng nhập. Tạo Registry. Tạo User và Group cho dự án. Cấu hình User vừa tạo có quyền Admin. Tạo Group. Như vậy đã tạo User và Group thành công.\nVậy chúng ta đã vừa tạo và thiết lập thành công Private Registry với Portus.\n"
},
{
	"uri": "//localhost:1313/2-preparation/",
	"title": "Thiết lập dự án",
	"tags": [],
	"description": "",
	"content": "Tổng quan Trong buổi Workshop này, chúng ta sẽ cùng nhau triển khai (deploy) một ứng dụng web sử dụng MERN Stack.\nMERN Stack bao gồm bốn thành phần chính: MongoDB, Express.js, React, và Node.js.\nMongoDB – NoSQL database. ExpressJS – Backend web-application framework cho NodeJS. ReactJS – JavaScript library dùng cho phát triển UIs từ UI components. NodeJS – Môi trường runtime cho JavaScript, cho phép chạy mã JavaScript bên ngoài trình duyệt, cùng với các tính năng khác. Chúng ta sẽ triển khai dự án trong môi trường On-premise bằng cách tạo các máy chủ Ubuntu thông qua nền tảng ảo hóa VMware.\nDưới đây là danh sách các Server cần thiết:\n# OS Version Server Ram CPU Disk IP Username Domain Description 1 Ubuntu 24.04 Gitlab-Server 3Gb 2 20Gb 192.168.181.101 tranvi0910 gitlab.tranvix.vn 2 Ubuntu 24.04 Development Server 2Gb 1 20Gb 192.168.181.102 tranvi0910 3 Ubuntu 24.04 Build Server 2Gb 1 20Gb 192.168.181.103 tranvi0910 4 Ubuntu 24.04 Database Server 2Gb 1 20Gb 192.168.181.104 tranvi0910 Gitlab Server :\nĐây là server chính dùng để chạy GitLab, một nền tảng quản lý mã nguồn và DevOps. GitLab cung cấp các tính năng như quản lý dự án, kho lưu trữ mã nguồn, CI/CD (Continuous Integration/Continuous Deployment). IP \u0026amp; Domain: 192.168.181.100, gitlab.tranvix.vn - Cho phép truy cập GitLab qua địa chỉ IP cục bộ hoặc domain gitlab.tranvix.vn. Development Server :\nServer này được sử dụng cho môi trường phát triển. Các nhà phát triển có thể triển khai và kiểm thử mã nguồn tại đây trước khi đưa lên GitLab hoặc các môi trường khác. Build Server :\nServer này dành riêng cho việc xây dựng (build) mã nguồn từ các dự án. Nó có thể tích hợp với GitLab để tự động hóa quá trình build khi có mã mới được đẩy lên. Database Server :\nĐây là server chuyên dụng để lưu trữ cơ sở dữ liệu. Các ứng dụng khác, chẳng hạn như GitLab hoặc các ứng dụng trên Development Server, sẽ kết nối đến server này để truy vấn và lưu trữ dữ liệu. Việc sử dụng domain name thay vì địa chỉ IP cụ thể trong mục Domain có nhiều lợi ích, đặc biệt là trong bối cảnh truy cập GitLab. Domain name như gitlab.tranvix.vn dễ nhớ hơn so với một địa chỉ IP như 192.168.181.101. Điều này giúp người dùng dễ dàng truy cập vào GitLab mà không cần phải ghi nhớ hoặc tra cứu IP mỗi khi cần.\n"
},
{
	"uri": "//localhost:1313/1-introduce/1.3-tools/",
	"title": "DevSecOps Tools",
	"tags": [],
	"description": "",
	"content": "Table of Content Gitlab Runner Docker Snyk Trivy Scan Image Portus Arachni k6 Gitlab Runner Gitlab Runner là một công cụ mã nguồn mở, được viết bằng ngôn ngữ Go và do chính Gitlab tạo ra để phục vụ cho việc CI/CD cho các dự án được tạo trên Gitlab. Người dùng có thể tự cài đặt cho mình một runner trên server của mình hoặc sử dụng những runner do Gitlab cung cấp. Người dùng chỉ cần tạo 1 file .gitlab-ci.yml ở thư mục gốc của dự án, để khởi tạo CI/CD pipeline và chỉ định Gitlab runner nào sẽ được sử dụng.\nCác loại Gitlab Runner Shared Runner\nShared runners được chia sẻ giữa tất cả các dự án trong một instance GitLab. Chúng có thể được sử dụng bởi bất kỳ dự án nào mà không cần cấu hình đặc biệt.\nƯu điểm: Tiết kiệm tài nguyên và dễ dàng quản lý, đặc biệt hữu ích cho các dự án nhỏ hoặc các dự án không đòi hỏi tài nguyên đặc biệt.\nCách triển khai: Quản trị viên của instance GitLab sẽ cấu hình và đăng ký shared runners.\nGroup Runner\nGroup runners chỉ được sử dụng bởi các dự án nằm trong cùng một nhóm GitLab. Điều này giúp kiểm soát và phân phối tài nguyên cho các dự án liên quan.\nƯu điểm: Cung cấp sự kiểm soát tốt hơn về việc sử dụng tài nguyên giữa các dự án trong cùng một nhóm, đồng thời dễ dàng quản lý và theo dõi.\nCách triển khai: Chủ sở hữu của nhóm sẽ cấu hình và đăng ký group runners thông qua phần cài đặt của nhóm.\nSpecific Runner\nSpecific runners được gán trực tiếp cho một dự án cụ thể và chỉ phục vụ cho dự án đó. Điều này giúp đảm bảo rằng tài nguyên được dành riêng cho dự án này.\nƯu điểm: Đảm bảo tài nguyên được tối ưu và bảo mật hơn cho các dự án yêu cầu cấu hình đặc biệt hoặc có nhu cầu tài nguyên cao.\nCách triển khai: Chủ sở hữu của dự án sẽ cấu hình và đăng ký specific runners thông qua phần cài đặt CI/CD của dự án.\nMỗi loại runner đều có những ưu điểm và hạn chế riêng, tùy thuộc vào nhu cầu và quy mô của dự án mà bạn có thể chọn loại runner phù hợp để triển khai.\nDocker Docker là một nền tảng mã nguồn mở cho phép tạo, triển khai và quản lý các ứng dụng trong môi trường container hóa. Với Docker, các ứng dụng và các thành phần phụ thuộc của chúng được đóng gói vào các container, giúp đảm bảo tính nhất quán khi chạy trên mọi môi trường từ phát triển đến sản xuất.\nDocker cung cấp tính di động cao, hiệu suất tối ưu, và đơn giản hóa quy trình DevOps, giúp các nhóm phát triển và vận hành làm việc hiệu quả hơn. Các container nhẹ hơn so với máy ảo, khởi động nhanh hơn và có thể được chia sẻ qua Docker Hub, nơi chứa hàng ngàn hình ảnh container có sẵn.\nQuy trình tạo một container với Docker Viết Dockerfile: Tạo một tệp Dockerfile chứa các chỉ thị để Docker biết cách xây dựng hình ảnh (image) cho ứng dụng, bao gồm việc chọn base image, cài đặt các phụ thuộc, và thiết lập cấu hình.\nXây dựng hình ảnh Docker: Sử dụng lệnh docker build để tạo ra một hình ảnh Docker từ Dockerfile.\nChạy container: Sau khi tạo xong hình ảnh, sử dụng lệnh docker run để tạo và chạy một container từ hình ảnh đó.\nKiểm tra và quản lý container: Sử dụng các lệnh như docker ps, docker logs, và docker exec để kiểm tra và quản lý container đang chạy.\nDocker giúp đơn giản hóa việc phát triển, triển khai và vận hành các ứng dụng bằng cách sử dụng công nghệ container hóa. Điều này giúp đảm bảo tính nhất quán giữa các môi trường khác nhau và tối ưu hóa tài nguyên hệ thống.\nSnyk Snyk là một nền tảng bảo mật dành cho nhà phát triển, giúp phát hiện và khắc phục các lỗ hổng bảo mật trong mã nguồn, các thư viện mã nguồn mở, container, và cơ sở hạ tầng dưới dạng mã (Infrastructure as Code - IaC). Snyk tích hợp sâu vào quy trình phát triển phần mềm, cho phép các nhà phát triển kiểm tra và sửa chữa các lỗ hổng bảo mật ngay từ giai đoạn phát triển, trước khi phần mềm được triển khai.\nCác tính năng chính của Snyk: Quét mã nguồn mở (Open Source Security): Snyk có thể quét các dự án mã nguồn mở và phát hiện các lỗ hổng bảo mật trong các thư viện và phụ thuộc mà dự án sử dụng. Nó cung cấp các giải pháp cụ thể để sửa chữa các lỗ hổng này.\nQuét container (Container Security): Snyk kiểm tra các hình ảnh Docker để tìm ra các lỗ hổng bảo mật và đề xuất các giải pháp tối ưu, giúp giảm thiểu rủi ro khi triển khai ứng dụng trong container.\nQuét mã nguồn (Code Security): Snyk có khả năng quét mã nguồn của bạn để tìm các lỗ hổng bảo mật tiềm ẩn và giúp phát hiện các vấn đề ngay từ giai đoạn viết mã.\nQuét IaC (Infrastructure as Code Security): Snyk có thể kiểm tra các tệp cấu hình cơ sở hạ tầng (như Terraform, AWS CloudFormation) để đảm bảo chúng không chứa các lỗi cấu hình bảo mật.\nTích hợp DevOps: Snyk dễ dàng tích hợp vào các công cụ CI/CD như Jenkins, GitLab CI, CircleCI, cũng như các IDE và hệ thống quản lý mã nguồn như GitHub, GitLab, Bitbucket.\nSnyk giúp các nhà phát triển và đội ngũ DevOps chủ động bảo vệ phần mềm và hệ thống của mình bằng cách phát hiện sớm và sửa chữa các lỗ hổng bảo mật trong suốt quá trình phát triển và triển khai.\nTrivy Scan Image Trivy là một công cụ mã nguồn mở dùng để quét các lỗ hổng bảo mật và các vấn đề cấu hình trong các container, mã nguồn mở, và cơ sở hạ tầng dưới dạng mã (Infrastructure as Code - IaC). Trivy có khả năng quét các hình ảnh container để phát hiện các lỗ hổng bảo mật, giúp bảo vệ ứng dụng trước các rủi ro an ninh tiềm ẩn.\nCác tính năng chính của Trivy: Quét hình ảnh Docker: Trivy có thể quét các lớp trong hình ảnh Docker để phát hiện các lỗ hổng bảo mật đã biết. Điều này giúp đảm bảo rằng các hình ảnh container mà bạn triển khai không chứa các vấn đề bảo mật nghiêm trọng.\nTích hợp dễ dàng: Trivy có thể tích hợp vào quy trình CI/CD để tự động quét các hình ảnh container trước khi chúng được triển khai, giúp phát hiện các vấn đề bảo mật sớm trong quá trình phát triển.\nHỗ trợ nhiều ngôn ngữ và hệ thống: Ngoài container, Trivy còn hỗ trợ quét các kho mã nguồn mở và cơ sở hạ tầng dưới dạng mã, bao gồm Terraform, CloudFormation và Kubernetes.\nKết quả chi tiết và dễ hiểu: Trivy cung cấp các báo cáo chi tiết về các lỗ hổng, bao gồm mức độ nghiêm trọng (Critical, High, Medium, Low), phiên bản bị ảnh hưởng, và nếu có, cách khắc phục lỗ hổng.\nTrivy là một công cụ bảo mật mạnh mẽ và dễ sử dụng, giúp các nhà phát triển và nhóm DevOps bảo vệ ứng dụng của mình bằng cách phát hiện sớm các lỗ hổng bảo mật trong các hình ảnh container, mã nguồn mở, và cơ sở hạ tầng dưới dạng mã.\nPortus Portus là một giao diện quản lý và dịch vụ bảo mật cho các registry Docker có thể self-host, giúp quản lý và kiểm soát các hình ảnh Docker trong một tổ chức. Được phát triển bởi SUSE, Portus cung cấp các tính năng bổ sung mà Docker Registry không có, như kiểm soát truy cập, giám sát, và quản lý người dùng. Điều này giúp đảm bảo rằng chỉ những người hoặc dịch vụ được ủy quyền mới có thể truy cập và quản lý các hình ảnh container.\nCác tính năng chính của Portus: Quản lý người dùng và nhóm: Portus cho phép quản lý người dùng và nhóm trong tổ chức, giúp thiết lập quyền truy cập khác nhau dựa trên vai trò của từng người dùng.\nKiểm soát truy cập: Với Portus, bạn có thể thiết lập các chính sách truy cập cho các dự án hoặc kho chứa (repositories) riêng biệt. Điều này giúp bảo vệ các hình ảnh quan trọng bằng cách hạn chế quyền truy cập.\nTích hợp Docker Registry: Portus tích hợp trực tiếp với Docker Registry, cung cấp một giao diện thân thiện và dễ sử dụng để quản lý các hình ảnh Docker.\nThông báo và giám sát: Portus cung cấp khả năng giám sát và gửi thông báo về các hoạt động trong Docker Registry. Điều này giúp các quản trị viên dễ dàng theo dõi các sự kiện quan trọng, như việc đẩy hoặc kéo hình ảnh.\nPortus là một giải pháp quản lý và bảo mật cho Docker Registry, cung cấp các tính năng mở rộng như kiểm soát truy cập, quản lý người dùng và giám sát, giúp các tổ chức quản lý hình ảnh Docker một cách an toàn và hiệu quả.\nArachni Arachni là một công cụ mã nguồn mở dùng để quét và phát hiện các lỗ hổng bảo mật trong ứng dụng web. Nó có khả năng phát hiện nhiều lỗ hổng phổ biến như SQL Injection, XSS, và CSRF.\nArachni cung cấp cả giao diện dòng lệnh (CLI) và giao diện web, giúp người dùng dễ dàng tích hợp vào các quy trình bảo mật.\nCông cụ này cũng hỗ trợ mở rộng thông qua các plugin hoặc module tùy chỉnh và cung cấp các báo cáo chi tiết ở nhiều định dạng như HTML, JSON, và XML.\nk6 k6 là một công cụ kiểm thử tải và đo hiệu suất mã nguồn mở, được phát triển bởi Grafana Labs. Với k6, người dùng có thể viết các kịch bản kiểm thử bằng JavaScript và thực hiện các bài kiểm thử hiệu suất với khả năng tạo ra hàng ngàn yêu cầu mỗi giây.\nk6 không yêu cầu giao diện đồ họa, phù hợp cho việc tự động hóa và tích hợp vào các hệ thống CI/CD. Công cụ này cũng hỗ trợ tích hợp với các dịch vụ giám sát hiệu suất như Grafana và Prometheus để theo dõi và phân tích kết quả kiểm thử.\n"
},
{
	"uri": "//localhost:1313/2-preparation/2.3-gitlabserver/",
	"title": "Gitlab Server",
	"tags": [],
	"description": "",
	"content": "Cài đặt Gitlab Tại Gitlab Server chúng ta đã tạo, tiến hành cài đặt và thiết lập các Dependency cần thiết.\nsudo apt-get update sudo apt-get install -y curl openssh-server ca-certificates tzdata perl Thêm GitLab package repository và cài đặt package.\ncurl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash Ở đây chúng ta cài đặt Gitlab Self-host có nghĩa là bạn thiết lập và chạy GitLab trên máy chủ của riêng mình, thay vì sử dụng dịch vụ lưu trữ của GitLab.\nĐiều này giúp bạn có toàn quyền kiểm soát môi trường GitLab, bao gồm việc quyết định nơi lưu trữ, cách cấu hình và ai có quyền truy cập.\nTiếp theo, cài đặt gói GitLab. Theo DNS mà bạn muốn dùng để truy cập vào Gitlab Server.\nsudo EXTERNAL_URL=\u0026#34;http://gitlab.tranvix.vn\u0026#34; apt-get install gitlab-ee Như vậy Gitlab đã cài đặt thành công.\nCấu hình Gitlab Tiến hành Add Host ở máy Windows.\nMở Notepad với quyền quản trị viên.\nMở tệp hosts ở địa chỉ C:\\Windows\\System32\\drivers\\etc\nỞ cuối tệp hosts, thêm một dòng mới với định dạng sau:\n\u0026lt;IP address\u0026gt; \u0026lt;domain name\u0026gt; Chúng ta sẽ thêm vào file địa chỉ IP máy ảo Gitlab Server và Domain chúng ta dùng truy cập vào Gitlab.\n192.168.181.101 gitlab.tranvix.vn Tiến hành truy cập vào Gitlab thông qua Domain http://gitlab.tranvix.vn\nLấy Password bằng cách thực hiện câu lệnh sau và tiến hành đăng nhập với Username root và Password vừa lấy:\ncat /etc/gitlab/initial_root_password root@gitlab-server:~# cat /etc/gitlab/initial_root_password # WARNING: This value is valid only in the following conditions # 1. If provided manually (either via `GITLAB_ROOT_PASSWORD` environment variable or via `gitlab_rails[\u0026#39;initial_root_password\u0026#39;]` setting in `gitlab.rb`, it was provided before database was seeded for the first time (usually, the first reconfigure run). # 2. Password hasn\u0026#39;t been changed manually, either via UI or via command line. # # If the password shown here doesn\u0026#39;t work, you must reset the admin password following https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password. Password: frA2Y0Aquj3AS3hLvKowNvUkMyfHD6mU4IdhDnOaSGU= # NOTE: This file will be automatically deleted in the first reconfigure run after 24 hours. Như vậy đã đăng nhập thành công.\nTạo Group, User và Project. Đầu tiên chúng ta tiến hành tạo Group để chứa dự án. Tiếp theo chúng ta sẽ tiến hành tạo User và thêm User và Group.\nTruy cập Admin và chọn New User Sau khi tạo User thành công tiến hành tạo Password. Thêm User vào Group. Truy cập vào Group, Tiến hành tạo Project. Chọn Create blank project. Đặt tên cho Project và chú ý bỏ chọn Initialize repository with a README phù hợp nếu bạn muốn đẩy một kho lưu trữ hiện có lên hoặc tự tạo các tệp sau. Tạo Project thành công. Thực hiện theo hướng dẫn có trên ảnh và tiến hành Push code dự án hiện có lên Gitlab.\nTải về dự án tại link bên dưới và di chuyển đến Server Development để có thể push code vào Gitlab.\nTại thư mục lưu trữ dự án ở Windows của bạn ấn chuột phải, tiến hành mở Terminal và chạy lệnh sau:\nscp .\\* tranvi0910@192.168.181.102:/home/tranvi0910 Lệnh dùng để sao chép tất cả tệp ./* và thư mục từ thư mục hiện tại trên máy cục bộ sang thư mục /home/tranvi0910 trên máy chủ từ xa có địa chỉ IP 192.168.181.102, với tài khoản người dùng tranvi0910.\nTiến hành kiểm tra ở Server Development.\nTạo thư mục mới để clone project về, sau đó giải nén source code chúng ta vừa di chuyển từ máy Windows qua Server và đẩy code lên Gitlab.\nmkdir -p /projects/wineapp \u0026amp;\u0026amp; cd /projects/wineapp Tiến hành Add Host ở Server Development để có thể clone dự án từ Gitlab.\nvi /etc/hosts Clone Project.\ngit clone http://gitlab.tranvix.vn/wineapp/wineapp-frontend.git root@development-server:/projects/wineapp# git clone http://gitlab.tranvix.vn/wineapp/wineapp-frontend.git Cloning into \u0026#39;wineapp-frontend\u0026#39;... Username for \u0026#39;http://gitlab.tranvix.vn\u0026#39;: wineappdev Password for \u0026#39;http://wineappdev@gitlab.tranvix.vn\u0026#39;: warning: You appear to have cloned an empty repository. Cài đặt package Unzip.\nsudo apt install unzip Giải nén file zip source code Frontend.\nunzip wine-website-FE.zip\runzip wine-website-BE.zip Sau khi giải nén xong chúng ta có 2 thư mục. Di chuyển Source Code từ thư mục chúng ta vừa giải nén vào Project Frontend vừa Clone về.\ncp -rf wine-website-FE-main/* /projects/wineapp/wineapp-frontend/ Push Code.\ngit add . git commit -m \u0026#39;project(base): add base project\u0026#39; git push Kiểm tra dự án tại Gitlab. Như vậy dự án đã được đẩy lên Gitlab thành công, thực hiện tương tự với Project Backend\n"
},
{
	"uri": "//localhost:1313/3-pipeline/3.3-security-performance/",
	"title": "Security Scan và Performance Test",
	"tags": [],
	"description": "",
	"content": "Code Security Scan Stage Sau khi thiết lập build và push image chúng ta sẽ tiến hành thêm một Stage để quét bảo mật Source Code.\nsnykscan: stage: snykscan variables: GIT_STRATEGY: clone before_script: - snyk auth ${SNYK_API_TOKEN} script: - snyk test --json | snyk-to-html -do ${SNYKSCAN_FILE}.html || true tags: - wineapp-build-shell artifacts: paths: - ${SNYKSCAN_FILE}.html expire_in: 1 day Trong GitLab CI/CD, artifacts là các tệp hoặc thư mục được lưu lại từ một job sau khi job đó hoàn tất thực thi.\nCác artifacts thường được sử dụng để lưu trữ kết quả của quá trình build, kiểm tra, hoặc các thông tin quan trọng khác mà bạn muốn giữ lại và sử dụng trong các job khác trong pipeline.\npaths:\n${SNYKSCAN_FILE}.html Định nghĩa các file artifact mà job sẽ lưu lại sau khi thực thi. Trong trường hợp này, file HTML chứa kết quả quét bảo mật. expire_in: 1 day\nĐặt thời gian tồn tại của artifact là 1 ngày. Sau thời gian này, artifact sẽ bị xóa. Chúng ta sẽ tiến hành thêm Stage này vào .gitlab-ci.yml.\nChú ý tạo các Variables như SNYKSCAN_FILE và SNYK_API_TOKEN.\nSNYKSCAN_FILE: \u0026#34;SNYK_SECURITY_SCAN_${CI_PROJECT_NAME}_${CI_COMMIT_TAG}_${CI_COMMIT_SHORT_SHA}\u0026#34; Chúng ta sẽ tạo tag và pipeline sẽ được khởi động.\nSau khi chạy pipeline thành công sẽ có thêm 1 stage là Code Security Scan và có thêm một file chứa báo cáo chi tiết về quá trình Test, có thể tải ở đây:\nHoặc chúng ta có thể truy cập vào mục Artifacts:\nSau khi tải về tiến hành giải nén file và kiểm tra file report dưới dạng HTML.\nScan Image Stage Việc quét bảo mật của Image chúng ta sẽ thực hiện ngay sau khi chúng ta Build Image thành công.\nChúng ta sẽ thêm một stage để quét bảo mật Image:\ntrivy scan image: stage: trivy scan image variables: GIT_STRATEGY: none script: - docker run --rm -v $(pwd):/wineapp-frontend -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy clean --all - docker run --rm -v $(pwd):/${CI_PROJECT_NAME} -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image --format template --template \u0026#34;@contrib/html.tpl\u0026#34; --output /${CI_PROJECT_NAME}/${TRIVY_IMAGE_REPORT}.html ${IMAGE_VERSION} tags: - wineapp-build-shell only: - tags artifacts: paths: - ${TRIVYFS_REPORT}.html expire_in: 1 day Tạo một Variable để định nghĩa tên file report.\nTRIVY_IMAGE_REPORT: \u0026#34;TRIVYFS_SCAN_IMAGE_REPORT_${CI_PROJECT_NAME}_${CI_COMMIT_TAG}_${CI_COMMIT_SHORT_SHA}\u0026#34; Ở stage này chúng ta có 2 phần , cả hai đều sử dụng công cụ Trivy để quét các lỗ hổng bảo mật trong một Docker Image.\nPhần 1: Xóa tất cả dữ liệu tạm thời của Trivy để chuẩn bị cho lần quét mới.\ndocker run --rm: Chạy một container Docker và tự động xóa container sau khi hoàn thành công việc.\n-v $(pwd):/wineapp-frontend: Gắn thư mục hiện tại ($(pwd)) vào đường dẫn /wineapp-frontend trong container.\n-v /var/run/docker.sock:/var/run/docker.sock: Gắn Docker socket từ máy chủ vào container, cho phép container thực hiện các thao tác liên quan đến Docker.\naquasec/trivy clean --all: Sử dụng lệnh clean của Trivy để xóa tất cả dữ liệu tạm thời hoặc dữ liệu cũ mà Trivy đã tạo trong quá trình quét trước đó.\nPhần 2: Quét lỗ hổng bảo mật trong một Docker Image, tạo report dưới dạng HTML và lưu nó vào mục Artifacts.\naquasec/trivy image: Sử dụng lệnh image của Trivy để quét lỗ hổng bảo mật trên Docker Image chúng ta vừa tạo.\n--format template: Chỉ định định dạng đầu ra là template.\n--template \u0026quot;@contrib/html.tpl\u0026quot;: Sử dụng tệp mẫu HTML (html.tpl) để định dạng kết quả quét.\n--output /${CI_PROJECT_NAME}/${TRIVY_IMAGE_REPORT}.html: Chỉ định đường dẫn và tên tệp đầu ra cho báo cáo HTML. Báo cáo này sẽ được lưu trong thư mục của dự án với tên tệp phụ thuộc vào giá trị của biến ${TRIVY_IMAGE_REPORT}.\nThêm Stage vào file cấu hình và tạo tag, chúng ta sẽ kiểm tra Pipeline:\nSau khi chạy Pipeline thành công, kiểm tra mục Aritfacts để tải file Report từ Stage quét bảo mật Image.\nKiểm tra file Report:\nDeploy Dự Án Như vậy chúng ta đã thực hiện xong các bước test và kiểm tra trước khi chúng ta Deploy dự án, trong mục này chúng ta sẽ tiến hành Deploy dự án Front-End.\nChúng ta sẽ Deploy dự án ở Server Development.\ndeploy: stage: deploy variables: GIT_STRATEGY: none before_script: - docker login -u ${PORTUS_USER} -p ${PORTUS_PASSWORD} ${PORTUS_URL} script: - sudo su ${PROJECT_USER} -c \u0026#34;docker pull ${IMAGE_VERSION}; docker rm -f ${CI_PROJECT_NAME}; docker run --name ${CI_PROJECT_NAME} -dp ${FE_PORT} ${IMAGE_VERSION}\u0026#34; after_script: - docker logout ${PORTUS_URL} tags: - wineapp-dev-shell only: - tags Ở phần tags chúng ta sẽ để là wineapp-dev-shell do đây là tag của Gitlab-Runner được thiết lập ở Server Development.\nChúng ta sẽ tạo biến FE_PORT với giá trị là 3000:80 có nghĩa là khi bạn truy cập http://\u0026lt;ip_server_dev\u0026gt;:3000, yêu cầu này sẽ được chuyển tới cổng 80 của container, nơi ứng dụng bên trong container sẽ xử lý yêu cầu đó.\nJob deploy này là một bước triển khai tự động trong pipeline CI/CD của GitLab.\nNó thực hiện các thao tác liên quan đến Docker để Pull một Docker Image mà chúng ta đã Push lên, dừng container hiện tại, và khởi động lại container với phiên bản mới của ứng dụng.\nMọi việc được thực hiện dưới quyền của một người dùng cụ thể (PROJECT_USER) để đảm bảo bảo mật và phân quyền.\nChú ý:\nTrong phần script, chúng ta sử dụng lệnh sudo su để chuyển đổi người dùng. Thông thường, khi sử dụng lệnh này, bạn sẽ cần nhập mật khẩu. Tuy nhiên, trong quá trình chạy Pipeline, không có cách nào để nhập mật khẩu theo cách thủ công.\nDo đó, để tránh tình huống này, chúng ta sẽ cấu hình để người dùng GitLab Runner có thể chạy lệnh sudo su mà không cần nhập mật khẩu.\nTrên giao diện dòng lệnh, bạn cần nhập lệnh sudo visudo và cung cấp mật khẩu. Sau đó, thêm dòng sau vào tệp cấu hình để hoàn tất việc thiết lập:\ngitlab-runner ALL=(ALL) NOPASSWD: /bin/su Để lưu file chúng ta nhấn F2 + Y + Enter.\nThực hiện thay đổi ở Server Development.\nSau khi cấu hình, chúng ta sẽ thêm Stage vào Pipeline và tạo Tag.\nNhư vậy chúng ta đã chạy Pipeline thành công, tiến hành kiểm tra ở địa chỉ sau:\n192.168.181.102:3000 192.168.181.102 là IP của Server Dev nơi chúng ta Deploy ứng dung.\n3000 là Port dùng để chạy ứng dụng được khai báo khi chúng ta Run Container.\nNhư vậy Web đã được Deploy thành công, chúng ta có thể kiểm tra Container bằng lệnh:\ndocker container ps Security Scan Website - Arachni Sau bước Deploy chúng ta sẽ tiến hành test bảo mật của trang Web chúng ta vừa triển khai.\nChúng ta sẽ thiết lập Arachni như ở Mục 2.7.\nWeb Application Security Scan security scan website: stage: security scan website variables: ARACHNI_USER: \u0026#34;arachni\u0026#34; PATH_TO_ARACHNI_VERSION: \u0026#34;/home/arachni/arachni-1.6.1.3-0.6.1.1/\u0026#34; GIT_STRATEGY: none script: - sudo su ${ARACHNI_USER} -c \u0026#34;cd ${PATH_TO_ARACHNI_VERSION}; bin/arachni --output-verbose --scope-include-subdomains ${ADDRESS_FRONTEND} --report-save-path=/tmp/${ARACHNI_WEBSITE_REPORT}.afr \u0026gt; /dev/null 2\u0026gt;\u0026amp;1\u0026#34; - sudo su ${ARACHNI_USER} -c \u0026#34;cd ${PATH_TO_ARACHNI_VERSION}; bin/arachni_reporter /tmp/${ARACHNI_WEBSITE_REPORT}.afr --reporter=html:outfile=/tmp/${ARACHNI_WEBSITE_REPORT}.html.zip\u0026#34; - sudo chmod 777 /tmp/${ARACHNI_WEBSITE_REPORT}.html.zip - cp /tmp/${ARACHNI_WEBSITE_REPORT}.html.zip . tags: - wineapp-dev-shell artifacts: paths: - ${ARACHNI_WEBSITE_REPORT}.html.zip expire_in: 1 day only: - tags Job security scan website này thực hiện quét bảo mật trên một website, tạo ra báo cáo bảo mật và lưu báo cáo đó dưới dạng một file .zip để bạn có thể tải về sau khi pipeline hoàn tất.\nADDRESS_FRONTEND là địa chỉ của web chúng ta 192.168.181.102:3000.\nARACHNI_WEBSITE_REPORT là tên của file report.\nKhi thực hiện lệnh sudo chmod cũng yêu cầu nhập mật khẩu nên chúng ta cũng cần cấu hình như ở trên.\ngitlab-runner ALL=(ALL) NOPASSWD: /bin/chmod Tiến hành thêm Stage vào Pipeline và tạo các Variable cần thiết, sau đó tạo tag và kiểm tra Pipeline.\nChúng ta sẽ có Report như sau: Performance Test - k6 Để kiểm tra hiệu năng của Website bằng k6 chúng ta sẽ tạo ra một file test được viết bằng JavaScript.\nimport http from \u0026#39;k6/http\u0026#39;; import { check, sleep } from \u0026#39;k6\u0026#39;; export let options = { vus: 1, duration: \u0026#39;10s\u0026#39;, }; export default function () { const BASE_URL = `${__ENV.FE_HOST}`; let res = http.get(BASE_URL); check(res, { \u0026#39;homepage status is 200\u0026#39;: (r) =\u0026gt; r.status === 200, }); sleep(1); } Sau đó chúng ta sẽ thêm file test vào repository chứa code.\nThêm Stage vào Pipeline:\nperformance testing: stage: performance testing variables: GIT_STRATEGY: none SCRIPT_PATH: performance_testing_script script: - sudo chmod -R 754 ./${SCRIPT_PATH} - docker run --user ${ID_USER_GITLAB_RUNNER}:${ID_GROUP_GITLAB_RUNNER} --rm -v $(pwd)/${SCRIPT_PATH}:/${SCRIPT_PATH} grafana/k6 run -e FE_HOST=${FE_HOST} --summary-export=/${SCRIPT_PATH}/summary_perf.json /${SCRIPT_PATH}/smoke_test.js - docker run --user ${ID_USER_GITLAB_RUNNER}:${ID_GROUP_GITLAB_RUNNER} --rm -v $(pwd)/${SCRIPT_PATH}:/${SCRIPT_PATH} grafana/k6 run -e FE_HOST=${FE_HOST} /${SCRIPT_PATH}/smoke_test.js - mv ./${SCRIPT_PATH}/summary.html $(pwd)/${K6_PERFORMANCE_TEST_REPORT}.html - cat ./${SCRIPT_PATH}/summary_perf.json | jq -r \u0026#39;[\u0026#34;metric\u0026#34;, \u0026#34;avg\u0026#34;, \u0026#34;min\u0026#34;, \u0026#34;med\u0026#34;, \u0026#34;max\u0026#34;, \u0026#34;p(90)\u0026#34;, \u0026#34;p(95)\u0026#34;], (.metrics | to_entries[] | [.key, .value.avg, .value.min, .value.med, .value.max, .value[\u0026#34;p(90)\u0026#34;], .value[\u0026#34;p(95)\u0026#34;]]) | @csv\u0026#39; \u0026gt; ${K6_PERFORMANCE_TEST_REPORT}.csv after_script: - sudo chown -R gitlab-runner $(pwd) tags: - wineapp-dev-shell artifacts: paths: - ${K6_PERFORMANCE_TEST_REPORT}.html - ${K6_PERFORMANCE_TEST_REPORT}.csv expire_in: 1 day only: - tags Job performance testing trong GitLab CI/CD được thiết kế để thực hiện kiểm thử hiệu suất cho dự án bằng cách sử dụng công cụ k6.\nDocker container dưới quyền user GitLab Runner thông qua các biến ID_USER_GITLAB_RUNNER và ID_GROUP_GITLAB_RUNNER.\nDocker container với k6 được khởi chạy để thực hiện kiểm thử dựa trên kịch bản smoke_test.js. Kết quả test được xuất ra dưới dạng tệp JSON summary_perf.json. Sau đó kết quả được di chuyển và chuyển đổi thành tệp HTML và CSV và lưu trữ vào artifacts.\nSau khi Pipeline chạy thành công chúng ta sẽ có file Report dưới dạng HTML.\n/\\ |‾‾| /‾‾/ /‾‾/\r/\\ / \\ | |/ / / /\r/ \\/ \\ | ( / ‾‾\\\r/ \\ | |\\ \\ | (‾) |\r/ __________ \\ |__| \\__\\ \\_____/ .io\rexecution: local\rscript: performance_testing_script/smoke_test.js\routput: -\rscenarios: (100.00%) 1 scenario, 1 max VUs, 40s max duration (incl. graceful stop):\r* default: 1 looping VUs for 10s (gracefulStop: 30s)\r✓ homepage status is 200\rchecks.........................: 100.00% ✓ 10 ✗ 0\rdata_received..................: 8.1 kB 808 B/s\rdata_sent......................: 860 B 86 B/s\rhttp_req_blocked...............: avg=240.69µs min=3.15µs med=4.21µs max=2.36ms p(90)=241.93µs p(95)=1.3ms\rhttp_req_connecting............: avg=124.41µs min=0s med=0s max=1.24ms p(90)=124.41µs p(95)=684.3µs\rhttp_req_duration..............: avg=512.44µs min=318.21µs med=491.68µs max=679.04µs p(90)=652.66µs p(95)=665.85µs\r{ expected_response:true }...: avg=512.44µs min=318.21µs med=491.68µs max=679.04µs p(90)=652.66µs p(95)=665.85µs\rhttp_req_failed................: 0.00% ✓ 0 ✗ 10\rhttp_req_receiving.............: avg=90.44µs min=38.49µs med=87.98µs max=129.07µs p(90)=128.62µs p(95)=128.84µs\rhttp_req_sending...............: avg=47.97µs min=15.66µs med=17.02µs max=305.24µs p(90)=64.64µs p(95)=184.94µs\rhttp_req_tls_handshaking.......: avg=0s min=0s med=0s max=0s p(90)=0s p(95)=0s\rhttp_req_waiting...............: avg=374.02µs min=229.34µs med=365.44µs max=529.58µs p(90)=519.81µs p(95)=524.69µs\rhttp_reqs......................: 10 0.998173/s\riteration_duration.............: avg=1s min=1s med=1s max=1s p(90)=1s p(95)=1s\riterations.....................: 10 0.998173/s\rvus............................: 1 min=1 max=1\rvus_max........................: 1 min=1 max=1\rrunning (10.0s), 0/1 VUs, 10 complete and 0 interrupted iterations\rdefault ✓ [======================================] 1 VUs 10s "
},
{
	"uri": "//localhost:1313/3-pipeline/",
	"title": "Thiết lập CI/CD Pipeline",
	"tags": [],
	"description": "",
	"content": "Diagram Sơ đồ này mô tả quy trình CI/CD tự động cho một ứng dụng web sử dụng MERN stack (MongoDB, Express.js, React.js, Node.js). Quy trình này giúp đảm bảo rằng mã nguồn được xây dựng, kiểm thử, quét bảo mật và triển khai một cách liên tục và hiệu quả.\nPush Code (Người dùng đến GitLab):\nDeveloper push source code của ứng dụng MERN stack lên kho lưu trữ GitLab. Hành động này sẽ kích hoạt quy trình CI/CD. Quy trình CI/CD (GitLab CI/CD):\nCommit: Khi mã nguồn được đẩy lên, một commit được tạo trong kho lưu trữ GitLab.\nGitLab CI/CD pipeline bắt đầu và bao gồm nhiều công việc (jobs) được thực hiện bởi các runner.\nBuild Job (GitLab Runner):\nBuild Frontend (React.js): GitLab Runner thực hiện việc build ứng dụng frontend bằng React.js, bao gồm cài đặt các dependencies và tạo các tệp tĩnh cần thiết.\nBuild Backend (Node.js và Express.js): Tương tự, backend được build bằng Node.js và Express.js, đảm bảo tất cả các dependencies được cài đặt và mã nguồn được biên dịch nếu cần.\nBuild Image Docker: Toàn bộ ứng dụng MERN stack được đóng gói vào một Docker image để dễ dàng triển khai và quản lý.\nQuét Image (Docker và Snyk):\nDocker image được quét để phát hiện các lỗ hổng bảo mật sử dụng công cụ như Snyk.\nGửi Báo cáo (đến Telegram): Kết quả quét bảo mật được gửi qua Telegram để thông báo cho nhóm phát triển về tình trạng bảo mật của image.\nCông việc Deploy (GitLab Runner):\nNếu quá trình build và quét bảo mật thành công, bước tiếp theo là triển khai ứng dụng. Triển khai Frontend và Backend: GitLab Runner triển khai frontend (React.js) và backend (Node.js và Express.js) lên môi trường sản xuất hoặc staging. Quản lý Image (Portus):\nPull Image (Portus): Docker image được quản lý thông qua Portus, nơi image được kéo từ registry này.\nPush Image (Portus): Sau khi quản lý, image được đẩy lên Harbor để lưu trữ và quét thêm các lỗ hổng bảo mật nếu cần.\nQuét Bảo mật (arachni):\nỨng dụng đã triển khai được quét bảo mật bằng công cụ arachni để phát hiện các lỗ hổng trong ứng dụng web. Kiểm thử Hiệu năng (k6):\nSau khi đảm bảo về bảo mật, kiểm thử hiệu năng được thực hiện bằng công cụ k6 để đảm bảo ứng dụng hoạt động tốt dưới tải cao.\nGửi Báo cáo: Kết quả kiểm thử hiệu năng được gửi qua Telegram để thông báo cho nhóm phát triển và vận hành.\n"
},
{
	"uri": "//localhost:1313/2-preparation/2.4-database/",
	"title": "Database Server",
	"tags": [],
	"description": "",
	"content": "Cài đặt MongoDB Tạo một EC2 Instance với cấu hình sau: Quá trình tạo EC2 xem lại phần 2.2.\nSau khi tạo thành công tiến hành Connect vào EC2 và tạo file bash script cài đặt MongoDB.\n#!/bin/bash\rsudo apt-get install gnupg curl\rcurl -fsSL https://www.mongodb.org/static/pgp/server-7.0.asc | \\\rsudo gpg -o /usr/share/keyrings/mongodb-server-7.0.gpg \\\r--dearmor\recho \u0026#34;deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse\u0026#34; | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list\rsudo apt-get update\rsudo apt-get install -y mongodb-org\recho \u0026#34;mongodb-org hold\u0026#34; | sudo dpkg --set-selections\recho \u0026#34;mongodb-org-database hold\u0026#34; | sudo dpkg --set-selections\recho \u0026#34;mongodb-org-server hold\u0026#34; | sudo dpkg --set-selections\recho \u0026#34;mongodb-mongosh hold\u0026#34; | sudo dpkg --set-selections\recho \u0026#34;mongodb-org-mongos hold\u0026#34; | sudo dpkg --set-selections\recho \u0026#34;mongodb-org-tools hold\u0026#34; | sudo dpkg --set-selections Chạy script trên bằng cách thực hiện lệnh sau:\nsh \u0026lt;name-file\u0026gt;.sh Sau khi cài đặt thành công, tiến hành khởi động MongoDB Community Edition.\nsudo systemctl start mongod Kiểm tra xem MongoDB đã khởi động thành công chưa bằng lệnh:\nsudo systemctl status mongod Có thể sử dụng tùy chọn để đảm bảo rằng MongoDB sẽ khởi động sau khi khởi động lại hệ thống bằng lệnh:\nsudo systemctl enable mongod Cấu hình MongoDB Truy cập vào file /etc/mongod.conf để thay đổi phạm vi địa chỉ IP mà MongoDB lắng nghe và chấp nhận kết nối.\nChuyển từ bindIp: 127.0.0.1 thành bindIp: 0.0.0.0\n127.0.0.1 (localhost): Đây là địa chỉ loopback của máy cục bộ (localhost). Nếu bindIp được đặt là 127.0.0.1, MongoDB sẽ chỉ chấp nhận kết nối từ chính máy tính nơi MongoDB đang chạy. Các kết nối từ bên ngoài (từ máy tính khác hoặc mạng khác) sẽ bị từ chối.\n0.0.0.0: Khi bindIp được đặt là 0.0.0.0, MongoDB sẽ lắng nghe trên tất cả các địa chỉ IP của máy chủ. Điều này có nghĩa là MongoDB sẽ chấp nhận kết nối từ bất kỳ IP nào, bao gồm cả máy tính cục bộ và các máy tính khác trong mạng.\nĐiều này giúp chúng ta có thể truy cập từ máy cục bộ đến máy ảo cài đặt MongoDB.\nSau khi thay đổi, tiến hành khởi động lại MongoDB.\nsudo systemctl restart mongod Tạo Firewall Rule để mở MongoDB Port ở EC2 Instance.\nTruy cập vào Instance -\u0026gt; Security. Chọn Security Group chứa Instance. Chọn Edit Inbound Rules.\nChọn Add Rule và chọn theo cấu hình sau: 27017 là Port dùng để chạy MongoDB.\nViệc mở port 27017 cho toàn bộ internet (0.0.0.0/0) có thể tạo ra rủi ro bảo mật cao. Nếu có thể, hãy giới hạn truy cập bằng cách chỉ cho phép địa chỉ IP hoặc dải IP đáng tin cậy.\nKết nối MongoDB Compass tới MongoDB trong EC2 Bạn có thể cài đặt MongoDB Compass ở link sau:\nMongoDB Compass Đây là giao diện chính của MongoDB Compass.\nỞ EC2 Instance chúng ta có Public IPv4 address và Public IPv4 DNS, chúng ta có thể truy cập đến Database thông qua chúng.\nTiến hành truy cập vào Database thông qua MongoDB Compass.\nThay đổi localhost thành địa chỉ IP Public của Instance và kết nối:\nSau khi kết nối thành công chúng ta đã có Database tương tự như trên Server:\nCó thể kiểm tra Database ở EC2 bằng lệnh:\nmongosh # Truy cập vào DB show dbs # Show danh sách DB "
},
{
	"uri": "//localhost:1313/3-pipeline/3.4-send-report/",
	"title": "Gửi Report vào Telegram",
	"tags": [],
	"description": "",
	"content": "Chuẩn Bị Để có thể gửi Report vào Telegram chúng ta cần tạo một tài khoản Telegram.\nSau khi tạo thành công chúng ta sẽ tìm kiếm BotFather để tiến hành tạo Bot.\nSau khi Start chúng ta sẽ tiến hành tạo Bot mới bằng cách nhập /newbot.\nKhi thực hiện xong các yêu cầu chúng ta sẽ được cung cấp 1 con Bot có thể truy cập thông qua đường link và một Token.\nĐể Bot có thể thông báo, chúng ta sẽ tiến hành tạo Group và thêm Bot vào.\nChúng ta cần biết ID của Group để có thể gửi tin nhắn vào, nên chúng ta cần thêm Bot RawDataBot để cung cập ID.\nChúng ta có thể test gửi một Message thông qua Server bằng lệnh sau:\ncurl -X POST \u0026#34;https://api.telegram.org/bot\u0026lt;Bot_Token\u0026gt;/sendMessage\u0026#34; -d \u0026#34;chat_id=\u0026lt;chat_id\u0026gt;\u0026#34; -d \u0026#34;text=test\u0026#34; curl -X POST \u0026#34;https://api.telegram.org/bot7538065344:AAEpk4atmTnmbl7knIbdQohOxrAfiG5tKi4/sendMessage\u0026#34; -d \u0026#34;chat_id=-4515541652\u0026#34; -d \u0026#34;text=test\u0026#34; Send Report Stage Chúng ta sẽ thêm một Stage để có thể gửi Report ngay sau khi cúng ta Test hoàn tất.\nStage này chúng ta sẽ có 2 Job.\nJob send report from build server nó sẽ thực hiện gửi 2 tệp báo cáo Code Security Scan và Image Scan được thực hiện trước khi chúng ta thực hiện triển khai dự án.\nJob send report from dev server tương tự như job trên, nó cũng thực hiện gửi các file Report sau khi chúng ta triển khai dự án.\nsend report from build server: stage: send report variables: GIT_STRATEGY: none script: - curl -F \u0026#34;chat_id=${TELE_GROUP_CHAT_ID}\u0026#34; -F \u0026#39;media=[{\u0026#34;type\u0026#34;:\u0026#34;document\u0026#34;,\u0026#34;media\u0026#34;:\u0026#34;attach://file1\u0026#34;}, {\u0026#34;type\u0026#34;:\u0026#34;document\u0026#34;,\u0026#34;media\u0026#34;:\u0026#34;attach://file2\u0026#34;}]\u0026#39; -F \u0026#34;file1=@$(pwd)/${SNYK_SECURITY_SCAN_REPORT}.html\u0026#34; -F \u0026#34;file2=@$(pwd)/${TRIVYFS_SCAN_IMAGE_REPORT}.html\u0026#34; \u0026#34;https://api.telegram.org/bot${API_BOT}/sendMediaGroup\u0026#34; tags: - wineapp-build-shell only: - tags send report from dev server: stage: send report variables: GIT_STRATEGY: none script: - curl -F \u0026#34;chat_id=${TELE_GROUP_CHAT_ID}\u0026#34; -F \u0026#39;media=[{\u0026#34;type\u0026#34;:\u0026#34;document\u0026#34;,\u0026#34;media\u0026#34;:\u0026#34;attach://file1\u0026#34;}, {\u0026#34;type\u0026#34;:\u0026#34;document\u0026#34;,\u0026#34;media\u0026#34;:\u0026#34;attach://file2\u0026#34;}, {\u0026#34;type\u0026#34;:\u0026#34;document\u0026#34;,\u0026#34;media\u0026#34;:\u0026#34;attach://file3\u0026#34;}]\u0026#39; -F \u0026#34;file1=@$(pwd)/${ARACHNI_WEBSITE_REPORT}.html.zip\u0026#34; -F \u0026#34;file2=@$(pwd)/${K6_PERFORMANCE_TEST_REPORT}.html\u0026#34; -F \u0026#34;file3=@$(pwd)/${K6_PERFORMANCE_TEST_REPORT}.csv\u0026#34; \u0026#34;https://api.telegram.org/bot${API_BOT}/sendMediaGroup\u0026#34; tags: - wineapp-dev-shell only: - tags Sau khi chạy pipeline Bot sẽ gửi cho chúng ta những file report ở các Stage trước.\n"
},
{
	"uri": "//localhost:1313/2-preparation/2.5-snyk/",
	"title": "Source Code Security - Snyk",
	"tags": [],
	"description": "",
	"content": "Cài đặt NodeJS và npm sudo apt install npm -y Kiểm tra Version.\ntranvi0910@deployment-server:~$ node -v v18.20.4 tranvi0910@deployment-server:~$ npm -v v10.7.0 Cài đặt Snyk với npm Cài đặt Snyk ở Server Build.\nnpm install snyk -g # Format HTML npm install snyk-to-html -g root@build-server:~# npm install snyk -g added 36 packages in 56s 12 packages are looking for funding run `npm fund` for details root@development-server:~# npm install snyk-to-html -g added 23 packages in 5s 1 package is looking for funding run `npm fund` for details Đăng nhập vào trang web chính thức của Snyk và tiến hành xác thực.\nLink Snyk Lấy API Token từ Account: Thực hiện câu lệnh sau ở Server Development để tiến hành xác thực.\nsnyk auth ab089484-2b45-4f10-b991-xxxxxxxxxxx root@build-server:~# snyk auth ab089484-2b45-4f10-b991-d101f237fecb Executable doesn\u0026#39;t exist, trying to download. Downloading from \u0026#39;https://static.snyk.io/cli/v1.1292.1/snyk-linux\u0026#39; to \u0026#39;/usr/lib/node_modules/snyk/wrapper_dist/snyk-linux\u0026#39; Shasums: - actual: xxxxxxxxxxxxxxx - expected: xxxxxxxxxxxxxxx Downloaded successfull! Your account has been authenticated. Snyk is now ready to be used. Di chuyển vào thư mục chứa dự án và tiến hành test:\ncd /projects/wineapp/wineapp-frontend\rsnyk test Có thể xem chi tiết các vấn đề bằng cách sử dụng lệnh sau:\nsnyk monit Có thể test và lưu ra 1 file HTML.\nsnyk test --json | snyk-to-html -o \u0026lt;name_file\u0026gt;.html Như vậy đã cài đặt và thiết lập Snyk thành công.\n"
},
{
	"uri": "//localhost:1313/2-preparation/2.6-trivy/",
	"title": "Trivy Security Scan Image",
	"tags": [],
	"description": "",
	"content": "Cài đặt Docker và Docker Compose Tạo file script .sh để cài đặt Docker và Docker Compose.\n#!/bin/bash sudo apt install -y apt-transport-https ca-certificates curl software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg echo \u0026#34;deb [signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt update -y sudo apt install docker-ce -y sudo systemctl start docker sudo systemctl enable docker sudo curl -L \u0026#34;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker -v docker-compose -v Chạy script trên bằng cách thực hiện lệnh sau:\nsh \u0026lt;name-file\u0026gt;.sh Như vậy đã cài đặt thành công Docker và Docker Compose.\nCài đặt Trivy thông qua Docker Image Trivy có các cách sử dụng sau:\n# Cài đặt Trivy\rbrew install aquasecurity/trivy/trivy\r# Quét một Docker image\rtrivy image your-docker-image\r# Quét file hệ thống\rtrivy fs /path/to/your/filesystem\r# Quét mã nguồn\rtrivy repo https://github.com/your/repo Trong bài Workshop này chúng ta sẽ cài đặt Trivy thông qua Docker Image.\nChúng ta có thể thực hiện việc test mã nguồn kết hợp với việc kéo Image Trivy từ Docker Hub.\ndocker run aquasec/trivy fs . Có thể tạo báo cáo quét Security bằng Trivy.\nTrivy Report Formats $ trivy image --format template --template \u0026#34;@contrib/html.tpl\u0026#34; -o report.html golang:1.12-alpine "
},
{
	"uri": "//localhost:1313/2-preparation/2.7-arachni/",
	"title": "Web Application Security Scan",
	"tags": [],
	"description": "",
	"content": "Web Application Security Scan với Arachni Sau khi dự án được Deploy thành công chúng ta có thể tiến hành quét bảo mật của Web.\nCài đặt Arachni ở Server Development, dự án được Deploy ở Server Development nên chúng ta sẽ thực hiện test trên server này.\nTạo User cho Arachni.\nadduser arachni Tải và giải nén file cài đặt Arachni.\nwget https://github.com/Arachni/arachni/releases/download/v1.5.1/arachni-1.5.1-0.5.12-linux-x86_64.tar.gz\rtar -xvf arachni-1.5.1-0.5.12-linux-x86_64.tar.gz Di chuyển vào thư mục vừa giải nén.\nThư mục bin là thư mục chứa các câu lệnh, có thể chạy lệnh thông qua thư mục bin.\nCó thể chạy lệnh sau để quét một trang Web bạn đã Deploy.\nbin/arachni --output-verbose --scope-include-subdomains http://\u0026lt;your-ip\u0026gt;:\u0026lt;port\u0026gt; --report-save-path=/tmp/\u0026lt;name-file\u0026gt;.afr http://\u0026lt;your-ip\u0026gt;:\u0026lt;port\u0026gt; : Là địa chỉ của Web.\nKết quả quét sẽ được lưu trong tệp \u0026lt;name-file\u0026gt;.afr.\nArachni Framework Report (.afr) là định dạng của file Report.\nCó thể chuyển thành file HTML bằng lệnh:\nbin/arachni_reporter /tmp/wineapp-frontend.afr --reporter=html:outfile=\u0026lt;name-file\u0026gt;.html.zip arachni@development-server:~/arachni-1.5.1-0.5.12$ bin/arachni_reporter /tmp/wineapp-frontend.afr --reporter=html:outfile=wineapp-backend.html.zip\rArachni - Web Application Security Scanner Framework v1.5.1\rAuthor: Tasos \u0026#34;Zapotek\u0026#34; Laskos \u0026lt;tasos.laskos@arachni-scanner.com\u0026gt;\r(With the support of the community and the Arachni Team.)\rWebsite: http://arachni-scanner.com\rDocumentation: http://arachni-scanner.com/wiki\r[*] HTML: Creating HTML report...\r[*] HTML: Saved in \u0026#39;wineapp-backend.html.zip\u0026#39;.\rarachni@development-server:~/arachni-1.5.1-0.5.12$ ls -l\rtotal 904\rdrwxrwxr-x 2 arachni arachni 4096 Mar 29 2017 bin\r-rw-rw-r-- 1 arachni arachni 6253 Mar 29 2017 LICENSE\r-rw-rw-r-- 1 arachni arachni 893570 Jul 21 15:24 wineapp-backend.html.zip \u0026lt;-----------------------------\r-rw-rw-r-- 1 arachni arachni 1929 Mar 29 2017 README\rdrwxrwxr-x 7 arachni arachni 4096 Mar 29 2017 system\r-rw-rw-r-- 1 arachni arachni 2078 Mar 29 2017 TROUBLESHOOTING\r-rw-rw-r-- 1 arachni arachni 13 Mar 29 2017 VERSION Tạo Docker Image Arachni ## Tools: Arachni ## OS: Ubuntu ## Version: v1 FROM ubuntu:latest RUN apt update -y \u0026amp;\u0026amp; \\ apt install -y wget tar \u0026amp;\u0026amp; \\ rm -rf /var/lib/apt/lists/* RUN wget https://github.com/Arachni/arachni/releases/download/v1.5.1/arachni-1.5.1-0.5.12-linux-x86_64.tar.gz \u0026amp;\u0026amp; \\ tar -xvf arachni-1.5.1-0.5.12-linux-x86_64.tar.gz \u0026amp;\u0026amp; \\ rm arachni-1.5.1-0.5.12-linux-x86_64.tar.gz WORKDIR /arachni-1.5.1-0.5.12 CMD [\u0026#34;bin/arachni\u0026#34;] Build Image.\ndocker build -t tranvi0910/arachni:v1.5.1-0.5.12 . Tiếp theo tiến hành đang nhập và push vào Dockerhub, khi chúng ta thực hiện quá trình CI/CD chỉ cần kéo Image về và thực hiện việc Test.\ndocker login\rdocker push tranvi0910/arachni:v1.5.1-0.5.12 Việc thiết lập và cài đặt Arachni đã hoàn thành.\n"
},
{
	"uri": "//localhost:1313/2-preparation/2.8-k6/",
	"title": "Performance Testing - k6",
	"tags": [],
	"description": "",
	"content": "Cài đặt k6 Tạo file shell script để cài đặt k6 ở Server Build.\n#!/bin/bash sudo gpg -k sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69 echo \u0026#34;deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main\u0026#34; | sudo tee /etc/apt/sources.list.d/k6.list sudo apt-get update sudo apt-get install k6 Tiến hành cài đặt.\nsh install-k6.sh Các loại Performance Testing Trước khi sử dụng k6, trước tiên chúng ta hãy hiểu định nghĩa và sự khác biệt của các loại Performance Testing này. Load Testing (Kiểm thử tải):\nĐây là quá trình kiểm tra phần mềm bằng cách áp dụng tải lớn mục đích đo lường và đánh giá các yếu tố như thời gian đáp ứng, tài nguyên tiêu tốn của hệ thống, sự ổn định của hệ thống dưới tải cao. Smoke Testing:\nKiểm thử này nhằm xác định liệu phiên bản phần mềm có thể khởi chạy và hoạt động bình thường với các chức năng cơ bản nhất hay không.\nĐây là bước kiểm thử ban đầu để quyết định xem phần mềm có đủ ổn định để thực hiện các kiểm thử chi tiết hơn.\nLoad Testing (for Performance):\nTập trung vào việc đánh giá hiệu suất của hệ thống dưới tải trọng cụ thể để đảm bảo hệ thống đáp ứng yêu cầu về hiệu suất như thời gian phản hồi và xử lý yêu cầu trong giới hạn cho phép. Stress Testing:\nKiểm thử này nhằm xác định giới hạn của hệ thống bằng cách áp dụng tải cao hơn so với tải dự kiến, tăng dần và giảm dần số lượng người dùng qua các mức để kiểm tra.\nMục đích là để tìm ra điểm gãy của hệ thống, từ đó có thể tối ưu hóa và chuẩn bị cho các tình huống tải cao đột ngột.\nSpike Testing:\nMột dạng cụ thể của Stress Testing, kiểm thử này mô phỏng các tình huống tải tăng đột ngột trong một khoảng thời gian ngắn để đánh giá khả năng của hệ thống trong việc xử lý các biến động tải đột ngột. Soak/Endurance Testing:\nKiểm thử này đánh giá hiệu suất của hệ thống dưới tải trọng trong một khoảng thời gian dài để xác định các vấn đề tiềm ẩn liên quan đến hiệu suất dài hạn như rò rỉ bộ nhớ hoặc suy giảm hiệu suất theo thời gian. Thiết lập k6 Test Ví dụ chúng ta sẽ tạo một file load-test.js và tiến hành test.\nimport http from \u0026#39;k6/http\u0026#39;; import { check, sleep } from \u0026#39;k6\u0026#39;; export let options = { vus: 100, duration: \u0026#39;10s\u0026#39;, thresholds: { http_req_duration: [\u0026#39;p(95)\u0026lt;500\u0026#39;] // 95% request dưới 500ms } }; export default function () { const BASE_URL = \u0026#39;http://192.168.181.104:3000/\u0026#39;; let res = http.get(BASE_URL); check(res, { \u0026#39;status was 200\u0026#39;: (r) =\u0026gt; r.status === 200, }); sleep(1); } Output\nroot@build-server:/tools/k6# k6 run load-test.js\r/\\ |‾‾| /‾‾/ /‾‾/\r/\\ / \\ | |/ / / /\r/ \\/ \\ | ( / ‾‾\\\r/ \\ | |\\ \\ | (‾) |\r/ __________ \\ |__| \\__\\ \\_____/ .io\rexecution: local\rscript: load-test.js\routput: -\rscenarios: (100.00%) 1 scenario, 100 max VUs, 40s max duration (incl. graceful stop):\r* default: 100 looping VUs for 10s (gracefulStop: 30s)\r✓ status was 200\rchecks.........................: 100.00% ✓ 811 ✗ 0\rdata_received..................: 781 kB 71 kB/s\rdata_sent......................: 70 kB 6.4 kB/s\rhttp_req_blocked...............: avg=14.71ms min=30.3µs med=44.3µs max=433.35ms p(90)=64.81ms p(95)=105.95ms\rhttp_req_connecting............: avg=10.95ms min=0s med=0s max=188.22ms p(90)=52.37ms p(95)=95.06ms\r✓ http_req_duration..............: avg=202.57ms min=2.04ms med=200.53ms max=508.74ms p(90)=337.88ms p(95)=384.15ms\r{ expected_response:true }...: avg=202.57ms min=2.04ms med=200.53ms max=508.74ms p(90)=337.88ms p(95)=384.15ms\rhttp_req_failed................: 0.00% ✓ 0 ✗ 811\rhttp_req_receiving.............: avg=1.67ms min=85.7µs med=150.2µs max=120.63ms p(90)=1.18ms p(95)=4.52ms\rhttp_req_sending...............: avg=31.14ms min=40µs med=69.8µs max=354.27ms p(90)=117.14ms p(95)=148.13ms\rhttp_req_tls_handshaking.......: avg=0s min=0s med=0s max=0s p(90)=0s p(95)=0s\rhttp_req_waiting...............: avg=169.76ms min=921.41µs med=151.78ms max=440.52ms p(90)=300.11ms p(95)=334.18ms\rhttp_reqs......................: 811 73.898412/s\riteration_duration.............: avg=1.29s min=1s med=1.29s max=1.68s p(90)=1.46s p(95)=1.5s\riterations.....................: 811 73.898412/s\rvus............................: 2 min=2 max=100\rvus_max........................: 100 min=100 max=100\rrunning (11.0s), 000/100 VUs, 811 complete and 0 interrupted iterations\rdefault ✓ [======================================] 100 VUs 10s data_received:\nTổng số dữ liệu nhận được từ máy chủ qua các yêu cầu HTTP trong suốt quá trình kiểm thử. data_sent:\nTổng số dữ liệu đã gửi đi từ client đến máy chủ qua các yêu cầu HTTP trong suốt quá trình kiểm thử. http_req_blocked:\nThời gian bị chặn trước khi yêu cầu HTTP được gửi đi (có thể do giới hạn băng thông, hạn chế tài nguyên\u0026hellip;).\nCho biết thời gian request phải chờ đợi trước khi được xử lý.\nhttp_req_connecting:\nThời gian kết nối với máy chủ sau khi gửi request. http_req_duration:\nThời gian hoàn thành toàn bộ yêu cầu HTTP, từ lúc bắt đầu đến khi hoàn thành toàn bộ phản hồi. http_req_failed:\nSố lượng yêu cầu HTTP thất bại (có thể do lỗi mạng, lỗi máy chủ\u0026hellip;). http_req_receiving:\nThời gian nhận dữ liệu từ máy chủ sau khi yêu cầu HTTP đã được gửi đi. http_req_sending:\nThời gian gửi dữ liệu yêu cầu đến máy chủ ( client -\u0026gt; server ). http_req_tls_handshaking:\nThời gian thiết lập kết nối an toàn (SSL)\nThời gian thực hiện bắt tay (handshake) TLS cho kết nối HTTPS.\nhttp_req_waiting:\nThời gian chờ đợi phản hồi từ máy chủ sau khi gửi yêu cầu HTTP. http_reqs:\nTổng số lượng yêu cầu HTTP đã được thực hiện. iteration_duration:\nThời gian thực hiện một vòng lặp (iteration) của kịch bản kiểm thử. iterations:\nTổng số vòng lặp (iterations) đã được thực hiện trong kịch bản kiểm thử. vus:\nSố lượng người dùng ảo (Virtual Users) hiện tại đang thực hiện kiểm thử. vus_max:\nSố lượng người dùng ảo tối đa trong quá trình kiểm thử. Như vậy chúng ta đã cài đặt thành công k6 và thực hiện test cơ bản.\n"
},
{
	"uri": "//localhost:1313/4-deployk8s/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " "
},
{
	"uri": "//localhost:1313/5-gitops/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]